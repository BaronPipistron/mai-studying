# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Концебалов О.С.
### группа: М8О-209Б-22

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список — это абстрактная структура данных, состоящая из узлов (node). Узел содержит данные и ссылку на один или два соседних узла. Списки в Prolog являются односвязными, т.е. каждый узел содержит лишь одну ссылку. При работе с односвязными списками необходимо выделять первый узел (называемый головой списка), остальные узлы (составляющие хвост списка) можно получить, передвигаясь по указателям вплоть до последнего узла. Хвост списка является таким же списком, как и исходный, поэтому обрабатывается аналогичным образом (рекурсивно).

В императивных языках, в отличие от Пролога, списки не являются основной структурой для хранения данных. В них чаще используются массивы (статические и динамические), но императивные языки более гибкие, так как программист всегда может написать собственную структуру данных. Одно из отличий списков в Prolog от схожих структур данных в императивных языках - программист не сталкивается с явной работой с указателями в узлах, только с интерфейсом структуры "список", в императивных же в зависимости от реализации программист может получать доступ непосредственно к ячейкам памяти компьютера (в куче) для работы с данными.

Что касается доступа к элементам списка, элемент данных в Прологе может быть очень быстро добавлен или удален из начала списка. Однако операция произвольного доступа (обращения к n-ному элементу) в Прологе выполняется гораздо дольше, чем в массивах императивных языков, т.к. требует n операций перехода по ссылкам. Императивные языки, напротив, позволяют получить доступ к любому элементу массива (статического и динамического) за O(1) по его индексу. Список в Прологе больше напоминает стек в императивных языках, так как в нем так же доступ осуществляется только к первому элементу, а остальные можно получить, рассмотрев оставшуюся часть после удаления первого элемента как новый стек.

## Задание 1.1: Предикат обработки списка

```prolog
standart_insert(Element, Position, List, ResList) ( custom_insert(Element, Position, List, ResList) ) - Вставка элемента в 
список на указанную позицию. Предикат принимает следующие аргументы: Элемент который необходимо вставить, позиция на которую 
необходимо вставить, список в который вставляем, новый список. Нумерация позиций в списке начинается с 0 (как в массивах в 
императивных языках).
```

Примеры использования:
```prolog
?- standart_insert(100, 3, [1, 2, 3, 4, 5], Res).
Res = [1, 2, 3, 100, 4, 5] .

?- standart_insert(100, 0, [1, 2, 3, 4, 5], Res).
Res = [100, 1, 2, 3, 4, 5] .

?- standart_insert(100, 0, [], Res).
Res = [100] .

?- standart_insert(100, -1, [], Res).
false.

?- standart_insert(100, 5, [1, 2, 3], Res).
false.
```
```prolog
?- custom_insert(200, 3, [1, 2, 3, 4, 5], Res).
Res = [1, 2, 3, 200, 4, 5] .

?- custom_insert(200, 3, [1, 2, 3, 4, 5], Res).
Res = [1, 2, 3, 200, 4, 5] .

?- custom_insert(200, 0, [], Res).
Res = [200] .

?- custom_insert(200, -1, [], Res).
false.

?- custom_insert(200, 5, [1, 2, 3], Res).
false.
```

Реализация:
```prolog
% 1 - С использованием стандартных предикатов

standart_insert(Element, 0, [H|T], ResList) :-
    my_append([Element], [H], NewList),
    my_append(NewList, T, ResList).

standart_insert(Element, 0, [], ResList) :-
    my_append([Element], [], ResList).

standart_insert(Element, Pos, [H|T], ResList) :-
    Pos > 0, 
    CurPos is Pos - 1,
    standart_insert(Element, CurPos, T, L),
    my_append([H], L, ResList).

% 2 - Без использования стандартных предикатов

custom_insert(Element, 0, [H|T], ResList) :-
    T \= [],
    ResList = [Element, H|T].

custom_insert(Element, 0, [], ResList) :-
    ResList = [Element].

custom_insert(Element, Pos, [H|T], ResList) :-
    Pos > 0,
    CurPos is Pos - 1,
    custom_insert(Element, CurPos, T, L),
    ResList = [H|L].
```

```prolog
standart_insert(Element, Position, List, ResList) (нумерация позиций (индексов) с 0): в случае если необходимо сделать вставку 
элемента на 0, то есть первую, позицию предикат standart_insert создает список [Element|T], где Т исходный список. В случае 
если мы добавляем элемент на первую позицию в пустой список, standart_insert создает список [Element|_], где _ будет пустым 
списком []. В остальных случаях (вставка на позицию отличную от 0) предикат рекурсивно вызывает себя и уменьшает значение 
счетчика Pos пока не дойдет до необходимой позиции, после чего добавляет необходимое значение в список. Если индекс выходит за
границы списка, то предикат вернет false. Так же false вернется если список пуст, а Pos != 1.
```

```prolog
custom_insert(Element, Position, List, ResList) (нумерация позиций (индексов) с 0): в случае если необходимо сделать вставку 
элемента на первую позицию (0 индекс), предикат custom_insert и в списке [H|T] T не пустой список, создает список [Element, H|
T], то есть просто добавляет элемент в начало, перед головой списка (некий push_front). Если добавляем элемент в пустой 
список, то просто создаем списко из этого элемента и возвращаем его. В ином случае доходим до необходимой позиции путем 
уменьшения Pos, делаем вставку аналогично первому случаю и возвращаем полученный список. Если индекс выходит за границы 
списка, то предикат вернет false. Так же false вернется если список пуст, а Pos != 1.
```

## Задание 1.2: Предикат обработки числового списка

```prolog
standart_first_negative_element_pos(List, Pos) ( custom_first_negative_element_pos(List, Pos) ) - Вычисление позиции первого 
отрицательного элемента в списке. Предикат принимает следующие аргументы: Список, Позиция первого отрицательного элемента. 
Нумерация позиций в списке начинается с 0 (как в массивах в императивных языках).
```

Примеры использования:
```prolog
?- standart_first_negative_element_pos([1, 2, -3, 5], Pos).
Pos = 2 .

?- standart_first_negative_element_pos([-1, 2, 3, 5], Pos).
Pos = 0 .

?- standart_first_negative_element_pos([1, 2, 3, 5], Pos).
false.
```
```prolog
?- custom_first_negative_element_pos([1, 2, -3, 5], Pos).
Pos = 2 .

?- custom_first_negative_element_pos([1, 2, 3, -5], Pos).
Pos = 3 .

?- custom_first_negative_element_pos([1, 2, 3, 5], Pos).
false.
```

```prolog
% 1 - С использованием стандартных предикатов

standart_first_negative_element_pos(List, Pos) :-
    my_append(Start, [X|_], List),
    X < 0,
    my_length(Start, Pos).

% 2 - Без использования стандартных предикатов

custom_first_negative_element_pos(List, Pos) :-
    first_negative_element_pos_handler(List, 0, Pos).

first_negative_element_pos_handler([H|_], Pos, Pos) :-
    H < 0.

first_negative_element_pos_handler([_|T], CurPos, Pos) :-
    NewPos is CurPos + 1,
    first_negative_element_pos_handler(T, NewPos, Pos).
```

```prolog
standart_first_negative_element_pos(List, Pos) (нумерация позиций с 0): предикат разделяет список на две части - Начальную 
Start и хвост со значением X в голове. После этого проверяетявляется ли Х отрицательным числом. Если да, то находит длину 
подсписка Start. В противном случае операции повторяются, X добавляется к Start. Если отрицательного значения в списке не
 будет, то предикат вернет false.
```

```prolog
custom_first_negative_element_pos(List, Pos) (нумерация позиций с 0): предикат берет первый элемент списка, проверяет его на 
отрицательность, в случае успеха возвращает позицию (0). В противном случае рекурсивно вызывает себя же, инкрементируя 
счетчик. Это происходит до тех пор пока не найдет отрицательный элемент. Если отрицательного элемента в списке не найдется, то 
предикат вернет false.
```

### Содержательные примеры на предикаты
```prolog
% вставить элемент перед первым отрицательным числом и после него
insert_before_and_after_first_neg_element(Element, List, ResList) :-
    standart_first_negative_element_pos(List, Pos), 
    custom_insert(Element, Pos, List, ResList1),
    custom_insert(Element, Pos + 2, ResList1, ResList).

% перемещение элемента в списке
move_element(Element, PosToMove, List, ResList) :-
    my_remove(Element, List, ResList1),
    custom_insert(Element, PosToMove, ResList1, ResList).
```

## Задание 2: Реляционное представление данных

Преимущества реляционного представления:
- Простая и читабельная форма изложения информации. Факты, как и записи в реляционных таблицах, имеют одинаковую структуру, а имена предикатов позволяют судить об отношениях их аргументов. Так, по названию предиката grade можно понять, что он должен описывать связь оценки с учеником, получившим ее, и предметом, по которому она была выставлена.
- Основа модели - математический аппарат, который позволяется строго описывать операции над данными (логика дизъюнктов Хорна).
- Возможность использования непроцедурных языков для работы.

Недостатки:
- Трудность изменения структуры данных. Добавить или убрать 1 или несколько аргументов одновременно из всех фактов - нетривиальная задача.
- Трудность проектирования реляционной базы данных. Так как изменять структуру предиката с ростом количества данных все труднее, необходимо перед написанием предикатов четко понимать задачи, для которых они будут использоваться. Также сложные отношения трудно переводятся в реляционное представление.
- Большой расход памяти для представления. Особенно это проявляется в случае, если данных мало, то есть имеется множество фактов, многие аргументы которых не определены. В таком случае от этих аргументов в конкретных фактах нельзя избавиться, их придется заполнить символами, обоначающими пустое значение.

Преимущества представления данных two.pl:
- Единообразие данных (используется только один предикат). Упрощает чтение и унифицирует работу с данными.
- Простая структура данных. Отсутствие списков списков и предикатов внутри предиката, как в three.pl. Упрощает восприятие.

Недостатки:
- Многочисленное дублирование данных: номеров групп, фамилий, предметов. Отчего, например, доступ к списку группы усложняется и зависит не только от числа учеников, но и от количества предметов. Если разбить исходный предикат на несколько, данные можно хранить более экономно.

Принципы реализации предикатов, осуществляющих запросы к данным:

```prolog
task1: предикат записывает в список Subject1 все предметы, встречающиеся в фактах из two.pl, при помощи setof в список Subject
 данные предметы записываются без повторений, далее печатается среднее арифметическое для каждого предмета (print_AVG).
```

```prolog
my_sum(List, Sum): List - список элементов, Sum - сумма элементов списка List. Предикат рекурсивно складывает элементы из 
списка, прибавляя модуль первого элемента списка к результату предиката от списка без этого элемента.
```

```prolog
find_AVG(Subject, Avg): предикат находит и записывает в список Marks всевозможные оценки по предмету Subject, далее находит 
сумму элементов и длину MArks и вычисляет среднее арифметическое оценок Avg.
```

```prolog
print_AVG(Subject): предикат рекурсивно выводит на экран средние оценки по предметам из списка предметов Subject, на каждом
 шаге рекурсии печатая информацию по первому предмету из списка.
```

```prolog
task2: находим всевозможные учебные группы из фактов из two.pl, записываем их в список Group без повторов (последовательное 
применение findall и setof), применяем к полученному списку групп предикат print_group_loosers(Group).
```

```prolog
find_group_loosers(Group, Count): подсчет количества оценок "2" студентов из группы Group (поиск и запись в список всех таких
 фактов, что группа = Group, оценка = 2, и подсчет длины этого списка). Так как у каждого ученика из фактов two.pl оценка по 
 предмету единственная, то предикат эквивалентен поиску количества несдавших студентов в группе.
```

```prolog
print_group_loosers(Group):рекурсивная печать для каждой группы из списка L количества несдавших студентов при помощи
 предиката find_group_loosers(Group, Count).
```

```prolog
task3: аходим всевозможные предметы из фактов, записываем их в список Subject без повторов (последовательное применение 
findall и setof), применяем к полученному списку групп предикат print_subject_loosers(Subject).
```

```prolog
find_subject_loosers(Subject, Count): подсчет количества несдавших (оценка "2") по предмету Subject аналогично failed(Group,
 Count), только условия для grade(A, B, C, D) в findall меняются на предмет = Subject, оценка = 2.
```

```prolog
print_subject_loosers(Subject): рекурсивная печать для каждого предмета из списка Subject количества несдавших студентов при
 помощи предиката failed_subject_loosers(Group, Count).
```

## Выводы

В процессе выполнения первой лабораторной работы я познакомился с языком логического программирования Prolog и его структурой данных список. Также я научился обрабатывать с помощью этого ЯП реляционный базы данных и написал стандартные предикаты для работы со списками и несколько своих кастомных. Это был довольно интересный и сложный опыт. Главная сложность заключалась в том, что было сложно переключиться с императивных ЯП (мой любимый С++) на декларативный Prolog. Он прямо заставил мозг поработать (флешбэки с Машины Тьюринга и ДМТ, ужас). Но в целом это был довольно интересный опыт, который показал мне насколько отличаются одни ЯП от других, и насколько одни подходы к программированию отличаются от других (уже страшно представить что будет на F#...). Лабораторная понравилась, мозг поработал, но хороший вопрос встречусь ли я с этим где-нибудь еще ?

Лабораторная на 8/10