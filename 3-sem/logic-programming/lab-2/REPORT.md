# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Концебалов О.С.
### группа: М8О-209Б-22

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует множество методов решения логических задач: метод рассуждений, табличный метод, метод графов, метод кругов Эйлера, метод равносильных логических преобразований (с использованием алгебры логики).

Пролог, в отличие от императивных языков программирования, работает непосредственно с данными и логическими правилами, из которых и состоит условие логических задач. То есть при решении логических задач на Прологе формат хранения данных и правил уже установлен языком, и программисту не нужно думать о том, как хранить данные в файле и внутри программы, какие структуры данных и синтаксические конструкции использовать для решения задачи, не нужно прописывать пошаговый алгоритм решения. Вместо этого задаются факты, правила и их взаимосвязь и формулируется цель (запрос), то есть Пролог позволяет программисту сосредоточиться на главном - на решении поставленной задачи.

## Задание

9. Один из пяти братьев разбил окно. Андрей сказал: Это или Витя, или Толя. Витя сказал: Это сделал не я и не Юра. Дима сказал: Нет, один из них сказал правду, а другой неправду. Юра сказал: Нет, Дима ты не прав. Их отец, которому, конечно можно доверять, уверен, что не менее трех братьев сказали правду. Кто разбил окно? 

## Принцип решения

```prolog
my_member(X, [X|_]).
my_member(X, [_|L]) :-
    my_member(X, L).

% Andrey
statement("Andrey", "Vitya").
statement("Andrey", "Tolya").

% Vitya
statement("Vitya", Guilty) :-
    Guilty \= "Vitya",
    Guilty \= "Yura".

% Dima
statement("Dima", Guilty) :-
    (statement("Andrey", Guilty), not(statement("Vitya", Guilty)));
    (statement("Vitya", Guilty), not(statement("Andrey", Guilty))).

% Yura
statement("Yura", Guilty) :-
    not(statement("Dima", Guilty)).

% Check statements to truth
check_statements([], _).
check_statements([H|T], Guilty) :-
    statement(H, Guilty),
    check_statements(T, Guilty).

% Find who lied
solution(Guilty) :-
    my_member(Guilty, ["Andrey", "Vitya", "Dima", "Yura", "Tolya"]),
    my_member(Lied, ["Andrey", "Vitya", "Dima", "Yura"]),
    delete(["Andrey", "Vitya", "Dima", "Yura"], Lied, Speakers),
    check_statements(Speakers, Guilty),
    !.

% Print result
print_ans :-
    solution(Guilty),
    format('~w break the window ~n', [Guilty]).
```

Решение строится на поиске не менее трех правдивых утверждений мальчиков путем перебора троек утверждений. Каждое высказывание обозначается предикатом say(X, Y), который обозначает, что X считает виновным Y. То есть предикаты должны быть определены для X, соответствующих именам высказавшихся мальчиков (Андрей - Andrew, Витя - Vitya, Дима - Dima, Юра - Yura). При помощи логических средств Пролога (логическое И - ",", логическое ИЛИ - ";", логическое отрицание - "not", неравенство - "\\=") утверждения мальчиков записываются следующим образом:

```prolog
% Andrey
statement("Andrey", "Vitya").
statement("Andrey", "Tolya").

% Vitya
statement("Vitya", Guilty) :-
    Guilty \= "Vitya",
    Guilty \= "Yura".

% Dima
statement("Dima", Guilty) :-
    (statement("Andrey", Guilty), not(statement("Vitya", Guilty)));
    (statement("Vitya", Guilty), not(statement("Andrey", Guilty))).

% Yura
statement("Yura", Guilty) :-
    not(statement("Dima", Guilty)).
```

С помощью предиката check_statements(X, Y) проверяем все ли утверждения мальчиков из списка X являются правдой. В случае
успеха Y будет указывать на виновника.

```prolog
% Check statements to truth
check_statements([], _).
check_statements([H|T], Guilty) :-
    statement(H, Guilty),
    check_statements(T, Guilty).
```

Предикат solution(Guilty) решает поставленную логическую задачу. Он подбирает предполагаемого виновника из списка всех мальчиков, а также предполагаемого лжеца из списка высказавшихся мальчиков. Толя молчал, поэтому он не учитывается при выборе лжеца. После чего, удаляя из списка говоривших возможного лжеца, проверяем правдивость утверждений оставшихся трех говоривших при помощи check_statements. Таким образом перебором вариантов выявляется виновник - тот, для которого нашлись трое (или четверо включая предполагаемого лжеца) мальчиков, сказавших правду.

```prolog
% Find who lied
solution(Guilty) :-
    my_member(Guilty, ["Andrey", "Vitya", "Dima", "Yura", "Tolya"]),
    my_member(Lied, ["Andrey", "Vitya", "Dima", "Yura"]),
    delete(["Andrey", "Vitya", "Dima", "Yura"], Lied, Speakers),
    check_statements(Speakers, Guilty),
    !.
```

С помощью предиката print_ans выводим в консоль ответ на поставленную задачу.

```prolog
% Print result
print_ans :-
    solution(Guilty),
    format('~w break the window ~n', [Guilty]).
```

Программа не зациклится, так как задача предполагает конечное количество определенных фактов, предикаты my_member и delete порождают конечное количество веток решения, каждая из которых по определению предиката tcheck_statements с учетом специфики предиката statement обязана завершиться успехом/неуспехом.

Для минимизации операций перебора условие "не менее трех братьев сказали правду" упрощено до "три брата сказали правду", так как бессмысленно проверять правдивость четвертого высказывания, если правдива тройка. Если ни одна тройка не правдива, то четверка также не будет правдива. При этом решения не теряются, так как перебором рассматриваются все возможные тройки. Также эффективность решения достигается за счет использования перебора не перестановок объектов-высказываний, а их сочетаний, то есть максимально (при неудачном расположении объектов в списке) будет рассмотрено всего 4!/(3!1!) = 4 тройки (4 высказывания; количество вариантов при переборе - это количество способов выбора 1 элемента из 4), а не 4! = 24 (количество перестановок 4 элементов). Тогда общее количество рассматриваемых перебором случаев (аргументы true_says) - 4 * 5 = 20, где 5 - количество возможных виновников. Сложность перебора - O(n*m), где n - количество ребят, m - количество высказавшихся. Чтобы исключить дальнейший перебор после нахождения первого и, как известно, единственного решения, было добавлено отсечение после проверки check_statements(Speakers, Guilty). То есть в случае, если в тройке есть неверное высказывание, check_statements примет значение false, и перебор продолжится, а иначе поиск решений будет завершен.

Непротиворечивость в данном случае достигается за счет отсутствия несоответствий между логикой решения задачи и реализацией этого решения средствами языка Пролог при условии, что исходная задача также имеет единственное решение.

## Выводы

В ходе выполнения лабораторной работы №2 я продолжил изучение языка Prolog и написания программ на нем. Я научился применять срадства Prolog'а для решения логических задач, а также закрепил навыки написания предикатов и работы со списками. Познакомился с новой для меня операцией отсечения. Был приятно удивлен, насколько просто можно описать логическую задачу на Prolog'е, в отличии от привычных императивных языков. Решение оказалось не самое оптимальное по сложности, но наиболее очевидное и простое для понимания. Несколько сложно оказалось проверить правильность полученного решения, но на мой взгляд ошибки не возникло. И отдельно хочется отметить, что, выполняя эту лабораторную, я увидел, что Prolog может пригодится в повседневной жизни для решения некоторых задач (ура, практические применения, которое не прочувствовал в 1й лабе).

Лабораторная на 9/10