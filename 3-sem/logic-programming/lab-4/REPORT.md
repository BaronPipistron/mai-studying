# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Концебалов О.С.

### группа: М8О-209Б-22

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует два основных подхода к обработке естественных языков (NLP): символический и статистический.

Символический подход основан на применении компьютером заданного набора правил к данным, с которыми он сталкивается. То есть он предполагает ручное кодирование набора правил в сочетании с поиском по словарю.

В статистическом подходе используется статистический анализ для автоматического изучения правил языка путем анализа больших корпусов типичных примеров реального мАлиса.

Статистический подход имеет множество преимуществ перед более ранним символьным подходом, так как ручное написание правил бывает излишне сложным, неэффективным применительно к конкретным задачам и является неустойчивым к незнакомым и ошибочным входным данным. Однако при недостаточном количестве обучающих данных успешное применение статистического подхода невозможно, и это одна из причин, почему символьный подход все еще актуален.

Что касается искусственных языков, для них характерна строгая структура и конкретные правила синтаксиса, семантики и пр. Это делает обработку подобных языков проще.

Пролог использует символический подход. Он удобен для анализа языков, так как позволяет легко и коротко описывать формальные грамматики: синтаксис прост, правила отображаются на предикаты Пролога, а слова на атомы. Кроме того, Пролог удобен в проведении синтаксического анализа, так как чтобы представить выражения в виде дерева, не нужно реализовывать структуру дерево, как на традиционном языке, и другие необходимые для решения конструкции. Вместо этого интерпретатор пролога естественным образом преобразует программу в дерево и выполняет по нему перебор с возвратами.

## Задание

10. Реализовать разбор фраз языка, представляющих собой положительные и отрицательные высказывания. В результате предикат должен выдавать все атомарные глубинные структуры.

Запрос:
```prolog
?- decompose(["Саша", "любит", "игрушки", ",", "но", "не", "любит", "кубики", "и", "мячи"],X).
?- decompose(["Алиса", "не", "любит", "стихи", "и", "прозы", ",", "а", "любит", "пьесы"],X).
```
Результат:
```prolog
X=likes("Саша", "игрушки").
X=not_likes("Саша", "кубики").
X=not_likes("Саша", "мячи").


X=not_likes("Алиса", "стихи").
X=not_likes("Алиса", "прозы").
X=likes("Алиса", "пьесы").
```

## Принцип решения

Для решения данной задачи необходимо использовать такую грамматику:
```
G = <VT={Лера, Иван, Саша, Алиса, ",", а, но, и, любит, не любит, игрушки, кубики, мячи, стихи, прозы, пьесы, театр, кино, сериалы, мультфильмы},
        VN={Decompose, Person, Info, Comma, But, VerbPh, Like, Nlike, Objs, And, Obj}, S=Decompose, P>, где VT - множество терминальных символов (слова), VN - множество нетерминальных символов (обозначения предикатов), S - начальный символ,  P - множество правил грамматики.
P:
Decompose -> Person Info
Info -> VerbPh Comma But VerbPh
VerbPh -> Like Objs | Nlike Objs
Objs -> Obj | Obj And Obj

Person -> Лера | Иван | Саша | Алиса
Comma -> ,
But -> а | но
Like -> любит
NLike -> не любит
And -> и
Obj -> игрушки | кубики | мячи | стихи | прозы | пьесы | театр | кино | сериалы | мультфильмы
```

По грамматике составляем Пролог-программу. Для этого сначала задаем факты person(X), object(X). Факты but(X) и одиночные like, nlike, and и comma относятся скорее к базе знаний, а не базе данных, поэтому они указаны ниже.
```prolog
person("Лера").
person("Иван").
person("Саша").
person("Алиса").

object("игрушки").
object("кубики").
object("мячи").
object("стихи").
object("прозы").
object("пьесы").
object("театр").
object("кино").
object("сериалы").
object("мультфильмы").
```
Далее составим правила в соответствии с грамматикой G:
```prolog
like(["любит"]).
nlike(["не", "любит"]).
comma(",").
but("но").
but("а").
and("и").
```
Предикат decompose(L, X) отделяет имя человека от фразы, проверяет его наличие в базе и передает его и оставшуюся часть фразы по отдельности в info, так как имя необходимо сохранить до самого конца работы программы, чтобы вывести ответ для X в виде фактов likes(имя, объект), not_likes(имя, объект).
```prolog
decompose([H|T], X) :- person(H), info(H, T, X).
```
Предикат info(Person, Text, X) отделяет одну из частей фразы (T1 до или T2 после запятой с союзом), в то же время проверяя правильность структуры предложения, и передает эти части предикату verbph по отдельности (правило "ИЛИ"), так как предикаты обрабатывают разные части фразы и могут иметь различные результаты, каждый из которых должен быть выведен.
```prolog
info(Person, Text, X) :-
	append(T1, [C, B | _], Text),
	comma(C), but(B), verbph(Person, T1, X).
info(Person, Text, X) :-
	append(_, [C, B | T2], Text),
	comma(C), but(B), verbph(Person, T2, X).
``
Предикат verbph(Person, Text, X) позволяет рассмотреть два случая: когда часть фразы положительная (получаем ответ X = likes(Person, Object)) и когда отрицательная (X = not_likes(P, O)). Он проверяет, что в начале фразы стоит "любит" или же "не любит" при помощи предикатов like(X) и nlike(X) и запускает поиск всех объектов object(X) при помощи предиката objs(Objects, Person, Object).
```prolog
verbph(Person, Text, likes(Person, Object)) :- append(L, Objects, Text), like(L), objs(Objects, Person, Object).
verbph(P, T, not_likes(P, O)) :- append(L, Os, T), nlike(L), objs(Os, P, O).
```
Первый предикат objs(Objects, Person, Object), который я реализовал, рекурсивно ищет все объекты, путем проверки каждого следующего слова на совпадение с фактами object(X). Это удобно, но, к сожалению, не полностью соответствует грамматике и не позволит использовать предикат decompose для проверки правильности предложения, так как количество объектов в предложении и вид разделителей между ними предикатом не ограничены.
```prolog
objs([H|_], _, H) :- object(H).
objs([_|T], P, O) :- objs(T, P, O).
```
Чтобы программа лучше соответствовала грамматике и могла использоваться для проверки предложений на правильность формата, я переписал предикат objs(Objects, Person, Object) так:
```prolog
objs([O], _, O) :- object(O).
objs([O, And, _], _, O) :- and(And), object(O).
objs([_, And, O], _, O) :- and(And), object(O).
and("и").
```
Для полного соответствия необходимо переписать правила 2-3 предиката objs так (но это излишне):
```prolog
objs([O1, And, O2], _, O1) :- object(O1), and(And), object(O2).
objs([O1, And, O2], _, O2) :- object(O1), and(And), object(O2).
```

## Результаты

```prolog
?- decompose(["Лера", "любит", "кино", "и", "мультфильмы", ",", "но", "не", "любит", "сериалы", "и", "театр"], X).
X = likes("Лера", "кино") ;
X = likes("Лера", "мультфильмы") ;
X = not_likes("Лера", "сериалы") ;
X = not_likes("Лера", "театр") ;
false.

?- decompose(["Лера", "любит", "прозы", "и", "пьесы", ",", "но", "не", "любит", "стихи"], X).
X = likes("Лера", "прозы") ;
X = likes("Лера", "пьесы") ;
X = not_likes("Лера", "стихи") ;
false.

?- decompose(["Иван", "любит", "театр", ",", "но", "не", "любит", "пьесы"],X).
X = likes("Иван", "театр") ;
X = not_likes("Иван", "пьесы") ;
false.

?- decompose(["Алиса", "любит", "игрушки", ",", "но", "не", "любит", "мультфильмы", "и", "стихи"], X).
X = likes("Алиса", "игрушки") ;
X = not_likes("Алиса", "мультфильмы") ;
X = not_likes("Алиса", "стихи") ;
false.
```

## Выводы

В процессе данной лабораторной работы я научился обрабатывать языковые данные, используя символьный подход, основанный на написании грамматики языка. Я понял, как преобразовывать грамматики в код на Прологе. Пролог - удобный инструмент для решения задач обработки языка, и несмотря на то, что сейчас такие задачи чаще решаются при помощи машинного обучения и нейросетей, для небольших задач или при малом объеме данных, его вполне можно использовать. В моем варианте написание программы обработки предложений на Прологе было также довольно простым и, как только я понял, что программа полностью повторяет грамматику, потребовались лишь знания, как правильно описывать грамматику и применять предикат append. На мой взгляд, в данном типе задач Пролог положительно выделяется, в отличие от императивных языков, где пришлось бы написать очень много сложного кода