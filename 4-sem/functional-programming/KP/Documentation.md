# Fython+ Programming Language Documentation
___
***Fython+ - это функциональный язык программирования, разработанный в рамках курсовой работы по дисциплине "Функциональное и логическое программирование". Реализован Fython+ с помощью языка программирования F#.***
___

***Особенности Fython+ :***
- функциональный (главная особенность языка)
- ленивый (вычисления не производятся, пока этого не попросят)
- не чуствителен к пробелам и табуляции
- нет необходимости ставить какие-либо символы после очередной инструкции
___

## Standart Library

- [Fundamental Types](#fundamental-types)
- [Output](#output)
- [Variables](#variables)
- [Arithmetic Operations](#arithmetic-operations)
- [Conditional Operators](#conditional-operators)
- [Functions](#functions)
- [Recursion](#recursion)
___

## Fundamental Types 

В языке Fython+ представлены следующие основные типы данных

- `Float` - вещественное тип (число с плавающей точкой)
- `Bool` - логический тип, принимает два значения `true` или `false`

***Примеры:***
```
Var floatType = 3.141592 // float
Var boolType = true
```

## Output

Операции вывода осуществляются с помощью функций `printf` и `printfn`.

Главное различие между ними - `printfn` осуществляет перенос строки после печати, а `printf` просто осуществляет печать.

```
printf <значение>

printfn <значение>
```
где:
 - `<значение>` - выражение, результат вычисления которого будет выведен в стандартный поток вывода

Функции `printf` и `printfn` в качестве аргумента могут принимать различные типы данных (логический тип, числа с плавающей точкой), а также результаты вычисления выражений и функций. Для вывода результата вычисления функции перед ней также необходимо поставить специальный символ `@` и указать аргументы, заключенные в `[ ]`.

***Примеры различного использования функций `printf` и `printfn`:***
```
printf 42 // Выведет число 42
printf true // Выведет логическое значение true

Let square [x] = {
    mult(x, x)
}

printf @ square [5] 
// Выведет результат вызова функции square с аргументом 5 (25)
```
```
printfn 42 // Выведет число 42
printfn true // Выведет логическое значение true

Let square [x] = {
    mult(x, x)
}
printfn @ square [5] 
// Выведет результат вызова функции square с аргументом 5 (25)
```

## Variables

Для определения переменной необходимо использовать ключевое слово `Var`.
```
Var <variable_name> = <variable_value>
```
где:
 - `Var` - ключевое словое, указывающее на определение новой переменной
 - `<variable_name>` - имя переменной
 - `=` - оператор присваивания
 - `<variable_value>` - значение, которым мы инициализируем нашу переменную

Переменная обязательно должа быть чем-то проинициализирована в момент создания. 

***Пример определения переменной:***
```
Var albhabetSize = 26
```
Важно помнить про области видимости переменных: объявление переменной
происходит в той области видимости, где она была определена. Другими словами, созданная Вами переменная будет доступна только в той области кода, где она была объявлена (блок кода, тело функции).
```
Let myFunction [x] = {
  Var y = mult(x, 2)
  printfn y // Выведет 10
}

printfn @ myFunction [5] // Выведет 10
printfn y // ERROR
```
Здесь мы объявили переменную `y` в теле функции `myFunction` и сразу проинициализировали ее значением `mult(x, 2)`. После этого мы распечатываем значение переменной `y` и результат работы функции. При попытке обратиться к
переменной `y` вне тела функции myFunction получаем ошибку.

## Arithmetic Operations

Язык Fython+ поддерживает основные математические операции

***Сложение (+)***
```
add(<operand_1>, <operand_2>)
```
где: 
 - `add` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

***Умножение (\*)***
```
mult(<operand_1>, <operand_2>)
```
где: 
 - `mult` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает результат вычисления выражения

***Вычитание (-)***
```
sub(<operand_1>, <operand_2>)
```
где: 
 - `sub` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает результат вычисления выражения

***Деление (/)***
```
div(<operand_1>, <operand_2>)
```
где: 
 - `div` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает результат вычисления выражения

***Равенство (==)***
```
eq(<operand_1>, <operand_2>)
```
где: 
 - `eq` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды, а также строки

Возвращает логический тип (`true` или `false`)

***Неравенство (!=)***
```
neq(<operand_1>, <operand_2>)
```
где: 
 - `neq` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды, а также строки

Возвращает логический тип (`true` или `false`)

***Оператор меньше (<)***
```
lt(<operand_1>, <operand_2>)
```
где: 
 - `lt` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает логический тип (`true` или `false`)

***Оператор больше (>)***
```
gt(<operand_1>, <operand_2>)
```
где: 
 - `gt` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает логический тип (`true` или `false`)

***Оператор меньше или равно (<=)***
```
leq(<operand_1>, <operand_2>)
```
где: 
 - `leq` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает логический тип (`true` или `false`)

***Оператор больше или равно (>=)***
```
geq(<operand_1>, <operand_2>)
```
где: 
 - `geq` - ключевое слово оператора сложения
 - `<operand_1>` - первый операнд
 - `<operand_2>` - второй операнд

Поддерживает как целочисленные, так и вещественные операнды

Возвращает логический тип (`true` или `false`)

***Примеры операций:***
```
// Сложение
Var x = add(5, 3) // 8

Var y = 2
Var z = 2
Var w = add(y, z) // 4
//------------------------

// Умножение
Var x = mult(2, 3) // 6

Var y = 2
Var z = 2
Var w = mult(y, z) // 4
//------------------------

// Вычитание
Var x = sub(2, 2) // 0

Var y = 4
Var z = 3
Var w = mult(y, z) // 1
//------------------------

// Деление
Var x = div(6, 2) // 3

Var y = 5
Var z = 2
Var w = div(y, z) // 2.5
//------------------------

// Равенство
Var x = eq(56, 3) // false

Var y = 2
Var z = 2
Var w = eq(y, z) // true
//------------------------

// Неравенство
Var x = neq(2, 3) // true

Var y = 2
Var z = 2
Var w = neq(y, z) // false
//------------------------

// Оператор меньше
Var x = lt(2, 3) // true

Var y = 2
Var z = 2
Var w = lt(y, z) // false
//------------------------

// Оператор больше
Var x = gt(2, 3) // false

Var y = 52
Var z = 2
Var w = gt(y, z) // true
//------------------------

// Оператор меньше или равно
Var x = leq(2, 2) // true

Var y = 43
Var z = 2
Var w = leq(y, z) // false
//------------------------

// Оператор больше или равно
Var x = geq(2, 3) // false

Var y = 52
Var z = 52
Var w = geq(y, z) // true
//------------------------
```
Это основные арифметические операции реализованные в Fython+. Они позволяют выполнять необходимые вычисления любой сложности, путем компинации этих операций.

## Conditional Operators

В Fython+ условные операторы реализованы с помощью конструкции `if-else`
```
if <condition> -> <code_if_condition_true>
else <code_if_condition_false>
```
где:
 - `if` - ключевое слово, которое указывает на начало конструкции условного оператора
 - `<condition>` - логическое выражение, которое проверяется на истинность (`true`) или ложность (`false`)
 - `->` - специальный оператор, который указывает на ветвь условного оператора в случае истинности логического выражение `<condition>`
 - `<code_if_condition_true>` - код, который будет выполнен в случае истинности логического выражение `<condition>`
 - `else` - ключевое слово, которое указывает на ветвь условного оператора в случае ложности логического выражение `<condition>`
 - `<code_if_condition_false>` - код, который будет выполнен в случае ложности логического выражение `<condition>`

Условный оператор работает следующим образом:

 - Сначала вычисляется `<condition>`
 - Если `<condition>` истинно (`true`), то выполняется `<code_if_condition_true>`, и его результат становится результатом всего условного оператора.
 - Если `<condition>` ложно (`false`), то выполняется `<code_if_condition_false>`, и его результат становится результатом всего условного оператора.
 
***Примеры использования условного оператора `if-else`:***
```
Let max [x, y] = {
    if gt(x, y) -> x
    else y
}
```
В этом примере функция `max` принимает два числа `x` и `y`, и возвращает наибольшее из них. Если `x` больше `y` (`gt(x, y)`), то функция возвращает `x`, иначе - `y`.

## Functions

Для объявления функции необходимо использовать ключевое слово `Let`.
```
Let <function_name> [<arguments>] = {
    <some_code>
}
```
где:
 - `Let` - ключевое словое, указывающее на определение новой функции
 - `<function_name>` - имя функции. Может содержать большие и маленькие английские буквы, цифры и специальные символы. Не может начинаться с цифр и специальных символов
 - `[<arguments>]` - аргументы функции, перечисленные через запятую. Аргументы заключаются в квадратные скобки `[ ]`. Если функция не принимает никаких аргументов, то в `[ ]` следует записать какой-либо фиктивный аргумент, который нигде не будет использоваться
 - `=` - оператор присваивания, который связывает имя функции и необходимые аргументы с телом нашей функции, которое как-либо обрабатывает переданные в нее аргументы
 - `{ }` - специальные символы, ограничивающие тело функции
 - `<some_code>` - непосредственной тело функции, код, который будет выполняться при ее вызове и как-либо обрабатывать переданные в нее аргументы

 ***Примеры определения функций с разным числом аргументов:***
 ```
// Функция без параметров
Let printHello [x] = { // x - фиктивный аргумент
    printfn "Hello, world!"
}

// Функция с одним параметром
Let square [x] = {
    mult(x, x)
}

// Функция с несколькими параметрами
Let sum [x, y, z] = {
    add(x, add(y, z))
}
 ```

***Вызов функции***

Вызов функции осуществляется с помощью специального оператора `@`, который необходимо разместить перед именем функции и переданными в нее аргументами в квадратных скобках. Например:
```
printfn @ square [5] // Выведет 25
printfn @ sum [1, 2, 3] // Выведет 6
```

Функции в Fython+ являются чистыми (не имеют побочных эффектов и всегда возвращают одно и то же значение для одних и тех же входных данных)

## Recursion

Язык Fython+ поддерживает возможность создания рекурсивных функций.

***Рекурсия - это концепция, при которой функция вызывает саму себя с разными входными данными до тех пор, пока не будет достигнуто некоторое базовое условие, после чего рекурсивные вызовы прекращаются. Рекурсия широко используется для решения задач, которые могут быть разбиты на более мелкие подзадачи той же природы (сортировки, работа со структурами данных, различные вычисления).***

Рекурсивные функции определяются так же как и обычные - с помощью ключевого слова `Let`. Однако в отличие от обычной функции, внутри тела рекурсивной функции присутствует вызов самой этой функции с измененными аргументами.

***Пример рекурсивного определения факториала:***
```
Let factorial [n] = {
    if eq(n, 0) -> 1
    else mult(n, @ factorial [sub(n, 1)])
}
```
В этом примере функция `factorial` принимает один параметр `n`. Внутри функции есть проверка условия выхода из рекурсии: если `n` равно `0`, функция возвращает `1` (так как факториал 0 равен 1 по определению). Иначе, функция вызывает саму себя с аргументом `sub(n, 1)` (n - 1), и умножает полученный результат на `n`. Таким образом, функция рекурсивно вычисляет факториал, постепенно уменьшая `n` до тех пор, пока не достигнет условия выхода из рекурсии (n == 0).

Крайне важным является условие прекращения рекурсии. Если его не написать или написать неправильно, то функция будет вызывать саму себя бесконечно, что черевато переполнением стека и ошибкой времени выполнения. 

***Пример правильного и неправильного определения рекурсивной функции:***
```
// Верное определение
Let factorial [n] = {
    if eq(n, 0) -> 1 // Условие выхода из рекурсии
    else mult(n, @ factorial [sub(n, 1)])
}

// Неверное определение
Let factorial [n] = {
    mult(n, @ factorial [sub(n, 1)]) 
    // Нет условия выхода из рекурсии
    // Stack Overflow
} 
```